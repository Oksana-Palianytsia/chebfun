
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>conformal2</title><meta name="generator" content="MATLAB 9.7"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2021-08-11"><meta name="DC.source" content="conformal2.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">CONFORMAL2  Doubly-connected conformal map to annulus</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> [f, finv, rho, pol, polinv] = conformal2(C1, C2, varargin)
</pre><h2 id="2">CONFORMAL2  Doubly-connected conformal map to annulus</h2><pre class="language-matlab">[F, FINV] = CONFORMAL2(C1, C2) computes <span class="string">a</span> <span class="string">conformal</span> <span class="string">map</span> <span class="string">F</span> <span class="string">of</span> <span class="string">the</span> <span class="string">smooth</span>
annular <span class="string">region</span> <span class="string">bounded</span> <span class="string">by</span> <span class="string">the</span> <span class="string">two</span> <span class="string">complex</span> <span class="string">periodic</span> <span class="string">chebfuns</span> <span class="string">C1</span> <span class="string">(outer</span>
boundary) and <span class="string">C2</span> <span class="string">(inner boundary, enclosing the origin)</span> <span class="string">to</span> <span class="string">a</span> <span class="string">circular</span>
annulus <span class="string">and</span> <span class="string">its</span> <span class="string">inverse</span> <span class="string">FINV.</span>  <span class="string">Both</span> <span class="string">maps</span> <span class="string">are</span> <span class="string">represented</span> <span class="string">by</span> <span class="string">function</span>
handles <span class="string">evaluating</span> <span class="string">rational</span> <span class="string">functions.</span>  <span class="string">The</span> <span class="string">circular</span> <span class="string">annulus</span> <span class="string">has</span> <span class="string">radii</span> <span class="string">1</span>
and <span class="string">RHO</span> <span class="string">&lt;</span> <span class="string">1</span>, the <span class="string">conformal</span> <span class="string">modulus</span>, which <span class="string">is</span> <span class="string">determined</span> <span class="string">as</span> <span class="string">part</span> <span class="string">of</span> <span class="string">the</span>
calculation.
</pre><pre class="language-matlab">CONFORMAL2(<span class="keyword">...</span><span class="comment">, 'tol', tol) uses tolerance tol instead of the default 1e-6.</span>
</pre><pre class="language-matlab">CONFORMAL2(<span class="keyword">...</span><span class="comment">, 'plots') produces plots of the map and its inverse.</span>
</pre><pre class="language-matlab">CONFORMAL2(<span class="keyword">...</span><span class="comment">, 'numbers') prints various quantities.</span>
</pre><pre class="language-matlab">[F, FINV, RHO, POL, POLINV] = CONFORMAL2(<span class="keyword">...</span><span class="comment">) returns the conformal modulus</span>
and the poles of F and FINV.
</pre><pre class="language-matlab">This <span class="string">experimental</span> <span class="string">code</span> <span class="string">is</span> <span class="string">only</span> <span class="string">good</span> <span class="string">for</span> <span class="string">very</span> <span class="string">simple</span> <span class="string">regions.</span>  <span class="string">Easy</span> <span class="string">to</span> <span class="string">break.</span>
</pre><pre class="language-matlab">Examples:
</pre><pre class="language-matlab">circle = chebfun(<span class="string">'exp(1i*pi*z)'</span>,<span class="string">'trig'</span>);
ellipse2 = real(circle) + .6i*imag(circle);
ellipse1 = (2+1i)*ellipse2 + .5;
conformal2(ellipse1, ellipse2, <span class="string">'plots'</span>);
</pre><pre class="language-matlab">z = chebfun(<span class="string">'exp(1i*pi*z)'</span>,<span class="string">'trig'</span>);
C1 = z.*abs(1+.1*z^4); C2 = .5*z.*abs(1+.2*z^3);
conformal2(C1, C2, <span class="string">'plots'</span>);
</pre><pre class="language-matlab">z = chebfun(<span class="string">'exp(pi*1i*t)'</span>,<span class="string">'trig'</span>);
C1 = z*(1+.1*randnfun(.5,<span class="string">'trig'</span>));
C2 = z*(.5+.1*randnfun(1,<span class="string">'trig'</span>));
[f, finv, rho] = conformal2(C1, C2, <span class="string">'plots'</span>, <span class="string">'numbers'</span>);
</pre><p>See also CONFORMAL.</p><pre class="language-matlab">Algorithm:
  (1) Use <span class="string">least-squares</span> <span class="string">to</span> <span class="string">find</span> <span class="string">constant</span> <span class="string">rho</span> <span class="string">&lt;</span> <span class="string">1</span> <span class="string">and</span> <span class="string">harmonic</span> <span class="string">u</span> <span class="string">s.t.</span>
      u(z) = -log(abs(z)) on <span class="string">C1</span> <span class="string">and</span>  <span class="string">u(z)</span> <span class="string">=</span> <span class="string">-log(abs(z))</span> <span class="string">+</span> <span class="string">log(rho)</span> <span class="string">on</span> <span class="string">C2</span>
  (2) Set <span class="string">f</span> <span class="string">=</span> <span class="string">z*exp(u(z)+iv(z))</span>;
  (3) Use <span class="string">AAA</span> <span class="string">to</span> <span class="string">approximate</span> <span class="string">f</span> <span class="string">and</span> <span class="string">its</span> <span class="string">inverse</span> <span class="string">by</span> <span class="string">rational</span> <span class="string">functions</span>
</pre><pre class="language-matlab">Although <span class="string">in</span> <span class="string">principle</span> <span class="string">these</span> <span class="string">algorithms</span> <span class="string">should</span> <span class="string">be</span> <span class="string">imbedded</span> <span class="string">in</span> <span class="string">the</span>
Chebfun <span class="string">constructor</span>, <span class="keyword">for</span> simplicity in <span class="string">this</span> <span class="string">numerically</span> <span class="string">challenging</span>
area <span class="string">we</span> <span class="string">have</span> <span class="string">not</span> <span class="string">done</span> <span class="string">that.</span>
</pre><p>This code was written by L. N. Trefethen mainly in October 2019.  For information about the use of AAA approximation, see Gopal and Trefethen, Representation of conformal maps by rational functions, Numer. Math. 142 (2019), 359-382.  See also Trefethen, Numerical conformal mapping with rational functions, Comp. Meth. Funct. Thy. 20 (2020), 369-387.</p><pre class="codeinput">t1 = tic;
[tol, plots, numbers, poly] = parseinputs(C1, C2, varargin{:});
err = Inf;

w1 = warning(<span class="string">'off'</span>, <span class="string">'MATLAB:rankDeficientMatrix'</span>);
logn = 4;
dom1 = domain(C1); dom1 = dom1([1 end]);    <span class="comment">% endpoints of parameter range</span>
dom2 = domain(C2); dom2 = dom2([1 end]);
errvec = [];
<span class="keyword">while</span> err &gt; tol
    n = round(2^logn);                      <span class="comment">% degree of polynomial</span>
    M = 8*n;                                <span class="comment">% # of sample points on each curve</span>
    MM = (1:M)';
    Z1 = C1(dom1(1) + MM*diff(dom1)/M);     <span class="comment">% sample points, outer curve</span>
    Z2 = C2(dom2(1) + MM*diff(dom2)/M);     <span class="comment">% sample points, inner curve</span>
    Z = [Z1; Z2];
    H = -log(abs(Z));                       <span class="comment">% RHS for Dirichlet problem</span>
    H(M+MM) = H(M+MM)+1;
    rvec = [zeros(M,1); ones(M,1)];
    [Hes, P] = VAorthog(Z,n);               <span class="comment">% orthogonalize nonnegative powers</span>
    [Hes2, P2] = VAorthog(Z.^(-1),n);       <span class="comment">% orthogonalize negative powers</span>
    A = [real(P) real(P2) -imag(P) -imag(P2) rvec];
    N = size(A,2);
    c = A\H;                                <span class="comment">% soln of least-squares problem</span>
    logrho = 1 - c(end);
    rho = exp(logrho);                      <span class="comment">% conformal modulus</span>
    err = norm(A*c-H, inf);                 <span class="comment">% max error</span>
    errvec = [errvec err];
    c(end) = [];
    c = reshape(c, [], 2)*[1; 1i];
    F = [P P2]*c;
    W = Z.*(exp(F));
    logn = logn + 1/2;
    <span class="keyword">if</span> (err &gt; tol) &amp;&amp; (logn &gt; 8)
        warning(<span class="string">'CONFORMAL2 did not converge'</span>)
        <span class="keyword">break</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
warning(w1.state, <span class="string">'MATLAB:rankDeficientMatrix'</span>)
<span class="comment">%semilogy(errvec,'.-','linewidth',1,'markersize',10), grid on, pause</span>

w2 = warning(<span class="string">'off'</span>, <span class="string">'CHEBFUN:aaa:Froissart'</span>);
[f, pol] = aaa(W, Z, <span class="string">'tol'</span>, tol);           <span class="comment">% forward map</span>
[finv, polinv] = aaa(Z, W, <span class="string">'tol'</span>, tol);     <span class="comment">% inverse map</span>
warning(w2.state, <span class="string">'CHEBFUN:aaa:Froissart'</span>)

<span class="comment">%inC = inpolygon(real(pol), imag(pol), ...  % check for poles of f in region</span>
<span class="comment">%                real(Z), imag(Z));</span>
<span class="comment">%if max(inC) &gt; 0</span>
<span class="comment">%    warning('CONFORMAL: pole in region')</span>
<span class="comment">%end</span>
<span class="comment">%if min(abs(polinv)) &lt; 1                    % check for poles of finv in disk</span>
<span class="comment">%    warning('CONFORMAL: pole in disk')</span>
<span class="comment">%end</span>
tcomp = toc(t1);

<span class="comment">% Plot solution if requested</span>
<span class="keyword">if</span> plots
    t2 = tic;
    clf
    LW = <span class="string">'linewidth'</span>; PO = <span class="string">'position'</span>; MS = <span class="string">'markersize'</span>;
    FW = <span class="string">'fontweight'</span>; NO = <span class="string">'normal'</span>; XT = <span class="string">'xtick'</span>; YT = <span class="string">'ytick'</span>;
    circ = exp(2i*pi*(0:300)'/300);

    h1 = axes(PO, [.04 .38 .45 .53]);       <span class="comment">% plot C1, C2 and poles of f</span>
    plot([C1 C2], <span class="string">'b'</span>, LW, 1)
    axis(1.2*norm(C1,inf)*[-1 1 -1 1])
    axis <span class="string">square</span>, hold <span class="string">on</span>, plot(pol, <span class="string">'.r'</span>, MS, 8)
    title([num2str(length(pol)) <span class="string">' poles'</span>],FW,NO)

    h2 = axes(PO, [.52 .38 .45 .53]);       <span class="comment">% plot annulus and poles of finv</span>
    plot([circ rho*circ], <span class="string">'b'</span>, LW, 1), axis(1.5*[-1 1 -1 1])
    axis <span class="string">square</span>, hold <span class="string">on</span>, set(gca,XT,-1:1,YT,-1:1)
    plot(polinv, <span class="string">'.r'</span>, MS, 8)
    title([num2str(length(polinv)) <span class="string">' poles'</span>],FW,NO)

    ncirc = 8;                  <span class="comment">% plot concentric circles and their images</span>
    <span class="keyword">for</span> r = rho + (1-rho)*(1:ncirc-1)/ncirc
        axes(h1), plot(finv(r*circ), <span class="string">'-k'</span>, LW, .5)
        axes(h2), plot(r*circ, <span class="string">'-k'</span>, LW, .5)
    <span class="keyword">end</span>

    nrad = 16;                  <span class="comment">% plot radii and their images</span>
    ray = chebpts(101,[rho 1]);
    <span class="keyword">for</span> k = 1:nrad
        axes(h1), plot(finv(ray*exp(2i*pi*k/nrad)), <span class="string">'-k'</span>, LW, .5)
        axes(h2), plot(ray*exp(2i*pi*k/nrad), <span class="string">'-k'</span>, LW, .5)
    <span class="keyword">end</span>

    axes(h1), hold <span class="string">off</span>
    axes(h2), hold <span class="string">off</span>
    tplot = toc(t2);

<span class="keyword">end</span>

<span class="comment">% Print various quantities if requested</span>
<span class="keyword">if</span> numbers
    disp(<span class="string">' '</span>)
    fprintf(<span class="string">'                 computation time in seconds:%6.2f\n'</span>, tcomp)
    <span class="keyword">if</span> plots
        fprintf(<span class="string">'                    plotting time in seconds:%6.2f\n'</span>, tplot)
    <span class="keyword">end</span>
    fprintf(<span class="string">'umber of sample points Z on each boundary, M:  %d\n'</span>, M)
    fprintf(<span class="string">'              numbers of poles of f and finv:  %d, %d\n'</span>, <span class="keyword">...</span>
        length(pol), length(polinv))
    fprintf(<span class="string">'       boundary error norm(Z-finv(f(Z)),inf):  %6.1e\n'</span>,<span class="keyword">...</span>
        norm(Z-finv(f(Z)), inf))
    fprintf(<span class="string">'        inverse error norm(W-f(finv(W)),inf):  %6.1e\n'</span>,<span class="keyword">...</span>
        norm(W-f(finv(W)), inf))
    fprintf(<span class="string">'                 interior inverse error norm:  %6.1e\n'</span>,<span class="keyword">...</span>
    norm(sqrt(rho)*W(1:M)-f(finv(sqrt(rho)*W(1:M))), inf))
    fprintf(<span class="string">'     max error of least-squares problem, err:  %6.1e\n'</span>, err)
    fprintf(<span class="string">'                        polynomial degree, n:  %d\n'</span>, n)
    fprintf(<span class="string">'        number of real degrees of freedom, N:  %d\n'</span>, 2*n+1)
    disp(<span class="string">' '</span>)
<span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">end</span>   <span class="comment">% end of conformal2</span>

<span class="keyword">function</span> [tol, plots, numbers, poly] = parseinputs(C1, C2, varargin)
tol = 1e-6;
plots = 0;
numbers = 0;
poly = 0;
j = 2;
<span class="keyword">while</span> j &lt; nargin
    j = j+1;
    v = varargin{j-2};
    <span class="keyword">if</span> strcmp(v, <span class="string">'tol'</span>)
        j = j+1;
        tol = varargin{j-2};
    <span class="keyword">elseif</span> strcmp(v, <span class="string">'plots'</span>)
        plots = 1;
    <span class="keyword">elseif</span> strcmp(v, <span class="string">'numbers'</span>)
        numbers = 1;
    <span class="keyword">elseif</span> strcmp(v, <span class="string">'poly'</span>)
        poly = 1;
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">%winding_number = sum(diff(C)/C)/(2i*pi);</span>
<span class="comment">%if abs(winding_number - 1) &gt; tol</span>
<span class="comment">%    error('CONFORMAL:parseinputs','C must wind once counterclockwise around 0')</span>
<span class="comment">%end</span>
<span class="keyword">end</span>   <span class="comment">% end of parseinputs</span>
</pre><pre class="codeoutput error">Error using evalin
Cannot find an exact (case-sensitive) match for 'Conformal2'

The closest match is: conformal2 in C:\Users\User\Dropbox\git\chebfun\conformal2.m
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019b</a><br></p></div><!--
##### SOURCE BEGIN #####
function [f, finv, rho, pol, polinv] = conformal2(C1, C2, varargin)
%% CONFORMAL2  Doubly-connected conformal map to annulus
%   [F, FINV] = CONFORMAL2(C1, C2) computes a conformal map F of the smooth
%   annular region bounded by the two complex periodic chebfuns C1 (outer
%   boundary) and C2 (inner boundary, enclosing the origin) to a circular
%   annulus and its inverse FINV.  Both maps are represented by function
%   handles evaluating rational functions.  The circular annulus has radii 1
%   and RHO < 1, the conformal modulus, which is determined as part of the
%   calculation.
%
%   CONFORMAL2(..., 'tol', tol) uses tolerance tol instead of the default 1e-6.
%
%   CONFORMAL2(..., 'plots') produces plots of the map and its inverse.
%
%   CONFORMAL2(..., 'numbers') prints various quantities.
%
%   [F, FINV, RHO, POL, POLINV] = CONFORMAL2(...) returns the conformal modulus
%   and the poles of F and FINV.
%
%   This experimental code is only good for very simple regions.  Easy to break.
%
%   Examples:
%
%   circle = chebfun('exp(1i*pi*z)','trig');
%   ellipse2 = real(circle) + .6i*imag(circle);
%   ellipse1 = (2+1i)*ellipse2 + .5;
%   conformal2(ellipse1, ellipse2, 'plots');        
%
%   z = chebfun('exp(1i*pi*z)','trig');
%   C1 = z.*abs(1+.1*z^4); C2 = .5*z.*abs(1+.2*z^3);
%   conformal2(C1, C2, 'plots');        
%
%   z = chebfun('exp(pi*1i*t)','trig');
%   C1 = z*(1+.1*randnfun(.5,'trig'));
%   C2 = z*(.5+.1*randnfun(1,'trig'));
%   [f, finv, rho] = conformal2(C1, C2, 'plots', 'numbers'); 
%
% See also CONFORMAL.

%%
%   Algorithm:
%     (1) Use least-squares to find constant rho < 1 and harmonic u s.t.
%         u(z) = -log(abs(z)) on C1 and  u(z) = -log(abs(z)) + log(rho) on C2
%     (2) Set f = z*exp(u(z)+iv(z));
%     (3) Use AAA to approximate f and its inverse by rational functions
%
%   Although in principle these algorithms should be imbedded in the
%   Chebfun constructor, for simplicity in this numerically challenging
%   area we have not done that.
%
% This code was written by L. N. Trefethen mainly in October 2019.  For
% information about the use of AAA approximation, see Gopal and Trefethen,
% Representation of conformal maps by rational functions, Numer. Math.
% 142 (2019), 359-382.  See also Trefethen, Numerical conformal mapping
% with rational functions, Comp. Meth. Funct. Thy. 20 (2020), 369-387.

t1 = tic;
[tol, plots, numbers, poly] = parseinputs(C1, C2, varargin{:});
err = Inf;

w1 = warning('off', 'MATLAB:rankDeficientMatrix');
logn = 4;
dom1 = domain(C1); dom1 = dom1([1 end]);    % endpoints of parameter range
dom2 = domain(C2); dom2 = dom2([1 end]);
errvec = [];
while err > tol
    n = round(2^logn);                      % degree of polynomial
    M = 8*n;                                % # of sample points on each curve
    MM = (1:M)';
    Z1 = C1(dom1(1) + MM*diff(dom1)/M);     % sample points, outer curve
    Z2 = C2(dom2(1) + MM*diff(dom2)/M);     % sample points, inner curve
    Z = [Z1; Z2];
    H = -log(abs(Z));                       % RHS for Dirichlet problem
    H(M+MM) = H(M+MM)+1;
    rvec = [zeros(M,1); ones(M,1)];
    [Hes, P] = VAorthog(Z,n);               % orthogonalize nonnegative powers
    [Hes2, P2] = VAorthog(Z.^(-1),n);       % orthogonalize negative powers
    A = [real(P) real(P2) -imag(P) -imag(P2) rvec];
    N = size(A,2);
    c = A\H;                                % soln of least-squares problem
    logrho = 1 - c(end);
    rho = exp(logrho);                      % conformal modulus
    err = norm(A*c-H, inf);                 % max error
    errvec = [errvec err];
    c(end) = [];
    c = reshape(c, [], 2)*[1; 1i];
    F = [P P2]*c;
    W = Z.*(exp(F));
    logn = logn + 1/2;
    if (err > tol) && (logn > 8)
        warning('CONFORMAL2 did not converge')
        break
    end
end
warning(w1.state, 'MATLAB:rankDeficientMatrix')
%semilogy(errvec,'.-','linewidth',1,'markersize',10), grid on, pause

w2 = warning('off', 'CHEBFUN:aaa:Froissart');
[f, pol] = aaa(W, Z, 'tol', tol);           % forward map
[finv, polinv] = aaa(Z, W, 'tol', tol);     % inverse map
warning(w2.state, 'CHEBFUN:aaa:Froissart')

%inC = inpolygon(real(pol), imag(pol), ...  % check for poles of f in region
%                real(Z), imag(Z));
%if max(inC) > 0
%    warning('CONFORMAL: pole in region')
%end
%if min(abs(polinv)) < 1                    % check for poles of finv in disk
%    warning('CONFORMAL: pole in disk')
%end
tcomp = toc(t1);

% Plot solution if requested
if plots
    t2 = tic;
    clf
    LW = 'linewidth'; PO = 'position'; MS = 'markersize';
    FW = 'fontweight'; NO = 'normal'; XT = 'xtick'; YT = 'ytick';
    circ = exp(2i*pi*(0:300)'/300);
  
    h1 = axes(PO, [.04 .38 .45 .53]);       % plot C1, C2 and poles of f
    plot([C1 C2], 'b', LW, 1)
    axis(1.2*norm(C1,inf)*[-1 1 -1 1])
    axis square, hold on, plot(pol, '.r', MS, 8)
    title([num2str(length(pol)) ' poles'],FW,NO)
  
    h2 = axes(PO, [.52 .38 .45 .53]);       % plot annulus and poles of finv
    plot([circ rho*circ], 'b', LW, 1), axis(1.5*[-1 1 -1 1])
    axis square, hold on, set(gca,XT,-1:1,YT,-1:1)
    plot(polinv, '.r', MS, 8)
    title([num2str(length(polinv)) ' poles'],FW,NO)
  
    ncirc = 8;                  % plot concentric circles and their images
    for r = rho + (1-rho)*(1:ncirc-1)/ncirc
        axes(h1), plot(finv(r*circ), '-k', LW, .5)
        axes(h2), plot(r*circ, '-k', LW, .5)
    end

    nrad = 16;                  % plot radii and their images
    ray = chebpts(101,[rho 1]);
    for k = 1:nrad
        axes(h1), plot(finv(ray*exp(2i*pi*k/nrad)), '-k', LW, .5)
        axes(h2), plot(ray*exp(2i*pi*k/nrad), '-k', LW, .5)
    end

    axes(h1), hold off
    axes(h2), hold off
    tplot = toc(t2);

end

% Print various quantities if requested
if numbers
    disp(' ')
    fprintf('                 computation time in seconds:%6.2f\n', tcomp)
    if plots
        fprintf('                    plotting time in seconds:%6.2f\n', tplot)
    end
    fprintf('umber of sample points Z on each boundary, M:  %d\n', M)
    fprintf('              numbers of poles of f and finv:  %d, %d\n', ...
        length(pol), length(polinv))
    fprintf('       boundary error norm(Z-finv(f(Z)),inf):  %6.1e\n',...
        norm(Z-finv(f(Z)), inf))
    fprintf('        inverse error norm(W-f(finv(W)),inf):  %6.1e\n',...
        norm(W-f(finv(W)), inf))
    fprintf('                 interior inverse error norm:  %6.1e\n',...
    norm(sqrt(rho)*W(1:M)-f(finv(sqrt(rho)*W(1:M))), inf))
    fprintf('     max error of least-squares problem, err:  %6.1e\n', err)
    fprintf('                        polynomial degree, n:  %d\n', n)
    fprintf('        number of real degrees of freedom, N:  %d\n', 2*n+1)
    disp(' ')
end

end   % end of conformal2

function [tol, plots, numbers, poly] = parseinputs(C1, C2, varargin)
tol = 1e-6; 
plots = 0;
numbers = 0;
poly = 0;
j = 2;
while j < nargin
    j = j+1;
    v = varargin{j-2};
    if strcmp(v, 'tol')
        j = j+1;
        tol = varargin{j-2};
    elseif strcmp(v, 'plots')
        plots = 1;
    elseif strcmp(v, 'numbers')
        numbers = 1;
    elseif strcmp(v, 'poly')
        poly = 1;
    end
end
%winding_number = sum(diff(C)/C)/(2i*pi);
%if abs(winding_number - 1) > tol
%    error('CONFORMAL:parseinputs','C must wind once counterclockwise around 0')
%end
end   % end of parseinputs

##### SOURCE END #####
--></body></html>